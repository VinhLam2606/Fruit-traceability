// lib/dashboard/bloc/organization_bloc.dart
import 'dart:async';
import 'dart:convert';
import 'dart:developer' as developer;

import 'package:bloc/bloc.dart'; // ‚úÖ S·ª≠a l·ªói import
import 'package:flutter/services.dart';
import 'package:web3dart/web3dart.dart';

import '../model/organization.dart';

part 'organization_event.dart';
part 'organization_state.dart';

class OrganizationBloc extends Bloc<OrganizationEvent, OrganizationState> {
  final Web3Client web3client;
  final EthPrivateKey credentials;

  late DeployedContract deployedContract;
  bool _isContractLoaded = false;

  // Khai b√°o c√°c h√†m trong Smart Contract s·∫Ω s·ª≠ d·ª•ng
  late ContractFunction _getUserFunction;
  late ContractFunction _getOrganizationFunction;
  late ContractFunction _addMemberFunction;
  late ContractFunction _isRegisteredFunction;

  OrganizationBloc({required this.web3client, required this.credentials})
    : super(OrganizationInitial()) {
    on<FetchOrganizationDetails>(_onFetchDetails);
    on<AddMemberToOrganization>(_onAddMember);
    on<RemoveMemberFromOrganization>(_onRemoveMember);
  }

  /// Kh·ªüi t·∫°o contract, load ABI v√† map c√°c h√†m c·∫ßn thi·∫øt.
  Future<void> _initializeContract() async {
    if (_isContractLoaded) return;

    final abiString = await rootBundle.loadString("build/contracts/Chain.json");
    final jsonAbi = jsonDecode(abiString);

    if (!jsonAbi.containsKey('abi') || !jsonAbi.containsKey('networks')) {
      throw Exception("‚ùå L·ªói file ABI: Thi·∫øu 'abi' ho·∫∑c 'networks'.");
    }

    final abi = ContractAbi.fromJson(jsonEncode(jsonAbi['abi']), 'Chain');
    final networks = jsonAbi['networks'] as Map<String, dynamic>;

    if (networks.isEmpty) {
      throw Exception(
        "‚ùå L·ªói file ABI: Kh√¥ng t√¨m th·∫•y network. B·∫°n ƒë√£ deploy contract v√† copy file JSON m·ªõi ch∆∞a?",
      );
    }

    final networkKey = networks.keys.first;
    final contractAddressHex = networks[networkKey]['address'] as String?;
    if (contractAddressHex == null || contractAddressHex.isEmpty) {
      throw Exception("‚ùå L·ªói file ABI: Kh√¥ng t√¨m th·∫•y ƒë·ªãa ch·ªâ contract.");
    }

    final contractAddress = EthereumAddress.fromHex(contractAddressHex);
    deployedContract = DeployedContract(abi, contractAddress);
    developer.log("üìå [OrgBloc] Contract ƒë√£ ƒë∆∞·ª£c load t·∫°i: $contractAddress");

    _getUserFunction = deployedContract.function('getUser');
    _isRegisteredFunction = deployedContract.function('isRegisteredAuth');
    _getOrganizationFunction = deployedContract.function('getOrganization');
    // Ch·ª©c nƒÉng n√†y kh√¥ng c√≥ trong Users.sol, b·∫°n c·∫ßn th√™m v√†o n·∫øu mu·ªën s·ª≠ d·ª•ng
    // _addMemberFunction = deployedContract.function('addAssociateToOrganization');

    _isContractLoaded = true;
  }

  /// Ki·ªÉm tra xem user hi·ªán t·∫°i c√≥ ph·∫£i l√† ch·ªß s·ªü h·ªØu t·ªï ch·ª©c hay kh√¥ng.
  Future<void> _checkIsOrganizationOwner() async {
    final address = credentials.address;

    final isRegisteredResult = await web3client.call(
      contract: deployedContract,
      function: _isRegisteredFunction,
      params: [address],
    );
    if (isRegisteredResult.isEmpty || !(isRegisteredResult.first as bool)) {
      throw Exception("‚ùå T√†i kho·∫£n ch∆∞a ƒë∆∞·ª£c ƒëƒÉng k√Ω.");
    }

    final userData = await web3client.call(
      contract: deployedContract,
      function: _getUserFunction,
      params: [address],
    );

    if (userData.isEmpty) {
      throw Exception("‚ùå Kh√¥ng l·∫•y ƒë∆∞·ª£c d·ªØ li·ªáu ng∆∞·ªùi d√πng t·ª´ blockchain.");
    }

    final userStruct = userData.first as List<dynamic>;

    // D·ª±a tr√™n struct UserDetails trong Types.sol:
    final BigInt role = userStruct[2] as BigInt;
    final bool inOrg = userStruct[3] as bool;

    // Ch·ªâ ng∆∞·ªùi c√≥ vai tr√≤ "Manufacturer" (gi√° tr·ªã 1) v√† ƒë√£ ·ªü trong m·ªôt t·ªï ch·ª©c m·ªõi ƒë∆∞·ª£c coi l√† Owner.
    if (role.toInt() != 1 || !inOrg) {
      throw Exception(
        "‚ùå T√†i kho·∫£n n√†y kh√¥ng ph·∫£i l√† ch·ªß s·ªü h·ªØu c·ªßa m·ªôt t·ªï ch·ª©c.",
      );
    }

    developer.log(
      "‚úÖ [OrgBloc] X√°c th·ª±c th√†nh c√¥ng: User l√† m·ªôt Organization Owner.",
    );
  }

  /// X·ª≠ l√Ω s·ª± ki·ªán fetch chi ti·∫øt t·ªï ch·ª©c
  Future<void> _onFetchDetails(
    FetchOrganizationDetails event,
    Emitter<OrganizationState> emit,
  ) async {
    emit(OrganizationLoading());
    try {
      await _initializeContract();
      await _checkIsOrganizationOwner();

      // G·ªçi h√†m getOrganization t·ª´ contract
      final result = await web3client.call(
        contract: deployedContract,
        function: _getOrganizationFunction,
        params: [credentials.address],
      );

      if (result.isEmpty || result.first is! List<dynamic>) {
        emit(OrganizationError("‚ùå D·ªØ li·ªáu tr·∫£ v·ªÅ t·ª´ contract kh√¥ng h·ª£p l·ªá."));
        return;
      }

      final rawOrg = result.first as List<dynamic>;

      // Ki·ªÉm tra tr∆∞·ªùng ownerAddress (index 2) ƒë·ªÉ xem c√≥ ph·∫£i ƒë·ªãa ch·ªâ r·ªóng kh√¥ng
      final EthereumAddress ownerAddress = rawOrg[2] as EthereumAddress;
      const zeroAddress = "0x0000000000000000000000000000000000000000";

      if (ownerAddress.hex.toLowerCase() == zeroAddress) {
        emit(
          OrganizationError(
            "‚ùå Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu Organization cho t√†i kho·∫£n n√†y.",
          ),
        );
        return;
      }

      final org = Organization.fromContract(rawOrg);
      developer.log(
        "‚úÖ [OrgBloc] ƒê√£ t·∫£i xong th√¥ng tin t·ªï ch·ª©c: ${org.organizationName}",
      );
      emit(OrganizationLoaded(org));
    } catch (e) {
      developer.log("‚ùå [OrgBloc] L·ªói khi fetch chi ti·∫øt:", error: e);
      emit(OrganizationError(e.toString()));
    }
  }

  /// X·ª≠ l√Ω s·ª± ki·ªán th√™m th√†nh vi√™n m·ªõi
  Future<void> _onAddMember(
    AddMemberToOrganization event,
    Emitter<OrganizationState> emit,
  ) async {
    emit(
      OrganizationError(
        "‚ö†Ô∏è Ch·ª©c nƒÉng th√™m th√†nh vi√™n ch∆∞a ƒë∆∞·ª£c tri·ªÉn khai tr√™n Smart Contract.",
      ),
    );
    // try {
    //   await _initializeContract();
    //   await _checkIsOrganizationOwner();

    //   final memberAddr = EthereumAddress.fromHex(event.memberAddress);

    //   final txHash = await web3client.sendTransaction(
    //     credentials,
    //     Transaction.callContract(
    //       contract: deployedContract,
    //       function: _addMemberFunction,
    //       parameters: [memberAddr],
    //     ),
    //     chainId: 1337,
    //   );

    //   developer.log("‚úÖ [OrgBloc] Giao d·ªãch th√™m th√†nh vi√™n ƒë√£ ƒë∆∞·ª£c g·ª≠i: tx=$txHash");
    //   emit(OrganizationActionSuccess("Y√™u c·∫ßu th√™m th√†nh vi√™n ƒë√£ ƒë∆∞·ª£c g·ª≠i. Vui l√≤ng ch·ªù x√°c nh·∫≠n."));

    //   await Future.delayed(const Duration(seconds: 2));
    //   add(FetchOrganizationDetails());

    // } catch (e) {
    //   developer.log("‚ùå [OrgBloc] L·ªói khi th√™m th√†nh vi√™n:", error: e);
    //   emit(OrganizationError("L·ªói khi th√™m th√†nh vi√™n: ${e.toString()}"));
    // }
  }

  /// X·ª≠ l√Ω s·ª± ki·ªán x√≥a th√†nh vi√™n
  Future<void> _onRemoveMember(
    RemoveMemberFromOrganization event,
    Emitter<OrganizationState> emit,
  ) async {
    emit(
      OrganizationError(
        "‚ö†Ô∏è Ch·ª©c nƒÉng x√≥a th√†nh vi√™n ch∆∞a ƒë∆∞·ª£c tri·ªÉn khai tr√™n Smart Contract.",
      ),
    );
  }
}
